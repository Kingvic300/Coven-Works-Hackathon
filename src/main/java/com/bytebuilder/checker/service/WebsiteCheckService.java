package com.bytebuilder.checker.service;

import com.bytebuilder.checker.dto.WebsiteAnalysisResult;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import okhttp3.*;
import javax.net.ssl.*;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j // Using Slf4j for consistent logging, instead of LoggerFactory
public class WebsiteCheckService {

    private final OkHttpClient client;
    // Advanced NLP service for content analysis
    private final NLPContentAnalyzer nlpAnalyzer;
    private final Gson gson; // Assuming Gson is also injected

    @Value("${virustotal.api.key}")
    private String virusTotalApiKey;

    @Value("${virustotal.poll.delay:3000}")
    private long pollDelayMillis;

    @Value("${virustotal.max.attempts:5}")
    private int maxVirusTotalAttempts;

    @Value("${content.scraping.timeout:10000}")
    private int scrapingTimeoutMs;

    // Suspicious URL patterns
    private static final Set<Pattern> SUSPICIOUS_URL_PATTERNS = Set.of(
            Pattern.compile(".*\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}.*"), // IP addresses
            Pattern.compile(".*[a-z0-9]{20,}\\.[a-z]{2,}.*"), // Very long subdomains, often generated by malware
            Pattern.compile(".*-[a-z0-9]{10,}\\.[a-z]{2,}.*"), // Suspicious hyphens with random chars
            Pattern.compile(".*(paypal|amazon|google|microsoft|apple).*\\.(tk|ml|ga|cf|gq|ga|top|xyz|loan|site|club|bid).*") // Typosquatting/scam TLDs
    );



    public CompletableFuture<WebsiteAnalysisResult> analyzeWebsiteAsync(String urlString) {
        return CompletableFuture.supplyAsync(() -> analyzeWebsite(urlString));
    }

    public WebsiteAnalysisResult analyzeWebsite(String urlString) {
        Instant startTime = Instant.now();

        try {
            // Validate and normalize URL
            String normalizedUrl = validateAndNormalizeUrl(urlString);

            // FIX: Reference the builder correctly using the nested class name
            // WebsiteAnalysisResult.builder() automatically returns the correct builder type
            // In WebsiteCheckService.java, line 93
            WebsiteAnalysisResult.WebsiteAnalysisResultBuilder resultBuilder = WebsiteAnalysisResult.builder()
                    .url(normalizedUrl);

            // Perform all checks
            boolean isSecure = checkHttpsSecurity(normalizedUrl);
            boolean isUrlSuspicious = checkUrlSuspiciousness(normalizedUrl);
            boolean isSafeFromScams = checkVirusTotalSafety(normalizedUrl);
            ContentAnalysis contentAnalysis = analyzeWebsiteContent(normalizedUrl);

            // Build result
            String safetyMessage = determineSafetyMessage(isSecure, isSafeFromScams,
                    contentAnalysis.isTextSafe(), isUrlSuspicious);

            Duration analysisTime = Duration.between(startTime, Instant.now());

            return resultBuilder
                    .description(contentAnalysis.getDescription())
                    .isSecure(isSecure)
                    .isSafeFromScams(isSafeFromScams)
                    .isTextSafe(contentAnalysis.isTextSafe())
                    .isUrlSuspicious(isUrlSuspicious)
                    .safetyMessage(safetyMessage)
                    .additionalInfo(Map.of(
                            "analysisTimeMs", analysisTime.toMillis(),
                            "suspiciousKeywordsDetected", contentAnalysis.getSuspiciousKeywords() // Use NLP result
                    ))
                    .analyzedAt(Instant.now())
                    .build();

        } catch (Exception e) {
            log.error("Failed to analyze website: {}", urlString, e);
            // Re-throw specific exceptions or wrap them, allowing @RestControllerAdvice to handle
            // For now, re-throwing IllegalArgumentException directly for the controller to catch.
            if (e instanceof IllegalArgumentException || e instanceof URISyntaxException) {
                throw new IllegalArgumentException("Invalid URL or format: " + e.getMessage(), e);
            }
            throw new RuntimeException("Website analysis failed for " + urlString, e);
        }
    }

    private String validateAndNormalizeUrl(String urlString) throws URISyntaxException {
        if (!StringUtils.hasText(urlString)) {
            throw new IllegalArgumentException("URL cannot be null or empty");
        }

        // Add protocol if missing
        if (!urlString.startsWith("http://") && !urlString.startsWith("https://")) {
            urlString = "https://" + urlString; // Default to HTTPS
        }

        URI uri = new URI(urlString);
        // Ensure host is present (e.g., prevents "https://" from being considered valid)
        if (uri.getHost() == null) {
            throw new IllegalArgumentException("Invalid URL format: missing host.");
        }
        return uri.toString();
    }

    private boolean checkUrlSuspiciousness(String urlString) {
        try {
            URI uri = new URI(urlString);
            String host = uri.getHost();

            if (host == null) return true;

            String lowerCaseUrl = urlString.toLowerCase();

            // Check against suspicious patterns
            for (Pattern pattern : SUSPICIOUS_URL_PATTERNS) {
                if (pattern.matcher(lowerCaseUrl).matches()) {
                    log.warn("Suspicious URL pattern detected: {} -> {}", lowerCaseUrl, pattern.pattern());
                    return true;
                }
            }

            // Check for excessive subdomains (e.g., a.b.c.d.example.com)
            // A simple count of dots in the host can indicate this.
            // A reasonable limit might be 3 or 4 (e.g., www.sub.domain.com).
            String[] hostParts = host.split("\\.");
            // Exclude common TLDs from the count for a more accurate check
            if (hostParts.length > 4) { // e.g., sub1.sub2.domain.co.uk (5 parts for a 2-part TLD)
                log.warn("Excessive subdomain levels detected ({} parts): {}", hostParts.length, host);
                return true;
            }

            return false;
        } catch (URISyntaxException e) {
            log.error("Error parsing URL for suspiciousness check: {}", urlString, e);
            return true; // Err on the side of caution
        } catch (Exception e) {
            log.error("Unexpected error checking URL suspiciousness: {}", urlString, e);
            return true; // Err on the side of caution
        }
    }

    @Data
    @AllArgsConstructor
    private static class ContentAnalysis {
        private final String description;
        private final boolean isTextSafe;
        private final Set<String> suspiciousKeywords;
    }

    private ContentAnalysis analyzeWebsiteContent(String urlString) {
        try {
            // Scrape website content with timeout
            Document doc = Jsoup.connect(urlString)
                    .timeout(scrapingTimeoutMs)
                    .userAgent("Mozilla/5.0 (Website Safety Checker; +https://yourdomain.com/about)") // Good practice to include contact info
                    .followRedirects(true)
                    .maxBodySize(1024 * 1024 * 2) // Increased limit to 2MB for richer content
                    .ignoreHttpErrors(true) // Sometimes legitimate sites return 4xx, still want to scrape content
                    .get();

            // Extract content for analysis
            String title = Optional.ofNullable(doc.title()).orElse("");
            String metaDescription = doc.select("meta[name=description]").attr("content");
            String heading = doc.select("h1, h2, h3").stream() // Include h3
                    .limit(5) // Get more headings
                    .map(el -> el.text().trim())
                    .collect(Collectors.joining(" "));

            String bodyText = doc.select("p, div, span").stream() // Include span elements
                    .map(element -> element.text().trim())
                    .filter(text -> text.length() > 20) // Filter out very short text snippets
                    .limit(10) // Collect more body text snippets
                    .collect(Collectors.joining(" "));

            // Combine all relevant text for NLP
            String rawContentForNLP = String.join(" ", title, metaDescription, heading, bodyText).trim();
            // Fallback to URL if no content is scraped (though analyzeContent expects non-empty)
            if (!StringUtils.hasText(rawContentForNLP)) {
                log.warn("No substantial content scraped for URL: {}", urlString);
                rawContentForNLP = urlString; // Use URL as a minimal content for analysis
            }


            // Analyze text safety with NLP
            NLPContentAnalyzer.NLPAnalysisResult nlpResult = nlpAnalyzer.analyzeContent(rawContentForNLP);
            boolean isTextSafe = nlpResult.isSafe();
            Set<String> suspiciousKeywords = nlpResult.getSuspiciousKeywords();

            // Generate intelligent summary using NLP
            // Use the NLP's sentiment score to influence summarization for more contextually relevant summaries
            String intelligentDescription = nlpAnalyzer.generateSummary(rawContentForNLP, 200);
            String finalDescription = StringUtils.hasText(intelligentDescription) ?
                    intelligentDescription : generateDescription(rawContentForNLP);


            log.info("Content analysis completed for URL: {}, description length: {}, NLP safety score: {}",
                    urlString, finalDescription.length(), nlpResult.getSafetyScore());

            return new ContentAnalysis(finalDescription, isTextSafe, suspiciousKeywords);

        } catch (IOException e) {
            log.error("Failed to scrape website content for {}: {}", urlString, e.getMessage());
            // It's important to provide a default/failed state rather than null or uninitialized.
            // Returning 'false' for isTextSafe and indicating scraping failure is appropriate.
            return new ContentAnalysis("Unable to scrape content: " + e.getMessage(), false, Set.of("scraping_failed"));
        } catch (Exception e) {
            log.error("An unexpected error occurred during content analysis for {}: {}", urlString, e.getMessage(), e);
            return new ContentAnalysis("An error occurred during content analysis.", false, Set.of("analysis_error"));
        }
    }

    private String generateDescription(String rawDescription) {
        if (!StringUtils.hasText(rawDescription)) {
            return "No description available";
        }

        // Clean up the description: replace multiple spaces with single, remove newline characters
        String cleaned = rawDescription.replaceAll("\\s+", " ").trim();
        cleaned = cleaned.replaceAll("[\\n\\r]", ""); // Remove newlines

        // Truncate if too long, ensuring we don't cut off mid-word if possible
        if (cleaned.length() > 200) {
            String truncated = cleaned.substring(0, 197);
            int lastSpace = truncated.lastIndexOf(" ");
            if (lastSpace != -1) {
                truncated = truncated.substring(0, lastSpace);
            }
            cleaned = truncated + "...";
        }

        return cleaned;
    }

    private String determineSafetyMessage(boolean isSecure, boolean isSafeFromScams,
                                          boolean isTextSafe, boolean isUrlSuspicious) {
        List<String> issues = new ArrayList<>();

        if (!isSecure) issues.add("lacks HTTPS security");
        if (!isSafeFromScams) issues.add("flagged by security scanners");
        if (!isTextSafe) issues.add("contains suspicious content");
        if (isUrlSuspicious) issues.add("has suspicious URL patterns");

        if (issues.isEmpty()) {
            return "Website appears to be safe.";
        } else if (issues.size() == 1) {
            return "Website is potentially unsafe: It " + issues.get(0) + ".";
        } else {
            return "Website is potentially unsafe: It " + String.join(", ", issues) + ".";
        }
    }

    public boolean checkHttpsSecurity(String urlString) {
        try {
            URI uri = new URI(urlString);
            if (!"https".equalsIgnoreCase(uri.getScheme())) {
                log.warn("Non-HTTPS URL provided, considering it insecure: {}", urlString);
                return false;
            }

            // Using OkHttp for HTTPS connection for consistency and better control
            Request request = new Request.Builder()
                    .url(urlString)
                    .head() // Use HEAD request to get headers only, faster than GET
                    .addHeader("User-Agent", "Website-Safety-Checker/1.0")
                    .build();

            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) {
                    log.warn("HTTPS connection failed or returned non-2xx for {}. Status: {}", urlString, response.code());
                    return false;
                }

                // Verify certificate chain (OkHttp handles most of this by default for trusted CAs)
                // If custom validation is needed, it would involve an X509TrustManager.
                // For a basic check, successful connection over HTTPS is often sufficient.
                Handshake handshake = response.handshake();
                if (handshake == null || handshake.peerCertificates().isEmpty()) {
                    log.warn("No SSL handshake or peer certificates found for HTTPS URL: {}", urlString);
                    return false;
                }

                log.info("Successfully validated HTTPS security for URL: {}", urlString);
                return true;
            }

        } catch (URISyntaxException e) {
            log.error("Invalid URL format for HTTPS check: {}", urlString, e);
            return false;
        } catch (SSLHandshakeException e) {
            log.warn("SSL Handshake failed for HTTPS URL: {}. This might indicate certificate issues or untrusted certs. Error: {}", urlString, e.getMessage());
            return false;
        }
        catch (IOException e) {
            log.error("HTTPS connection check failed for URL: {}. Error: {}", urlString, e.getMessage());
            return false;
        }
        catch (Exception e) {
            log.error("An unexpected error occurred during HTTPS security check for URL: {}", urlString, e);
            return false;
        }
    }

    public boolean checkVirusTotalSafety(String urlString) {
        if (!StringUtils.hasText(virusTotalApiKey)) {
            log.warn("VirusTotal API key not configured, skipping scan. Assuming safe for this check.");
            return true; // Don't fail the overall check if API key is not configured
        }

        try {
            // Submit URL for scanning
            String scanId = submitUrlForScanning(urlString);
            if (scanId == null) {
                log.warn("Failed to submit URL to VirusTotal for scanning: {}", urlString);
                return false;
            }

            // Poll for results
            return pollForScanResults(urlString, scanId);

        } catch (Exception e) {
            log.error("VirusTotal safety check failed for URL: {}: {}", urlString, e.getMessage(), e);
            return false;
        }
    }

    private String submitUrlForScanning(String urlString) throws IOException {
        RequestBody formBody = new FormBody.Builder()
                .add("url", urlString)
                .build();

        Request scanRequest = new Request.Builder()
                .url("https://www.virustotal.com/api/v3/urls")
                .post(formBody)
                .addHeader("x-apikey", virusTotalApiKey)
                .addHeader("User-Agent", "Website-Safety-Checker/1.0")
                .build();

        try (Response scanResponse = client.newCall(scanRequest).execute()) {
            String responseBody = Objects.requireNonNull(scanResponse.body()).string();
            if (!scanResponse.isSuccessful()) {
                log.warn("VirusTotal scan submission failed for URL: {}, status: {}, body: {}",
                        urlString, scanResponse.code(), responseBody);
                return null;
            }

            JsonObject scanJson = gson.fromJson(responseBody, JsonObject.class);
            // VirusTotal API v3 returns id under 'data' object directly
            // Example success: {"data":{"id":"u-0a8a6b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4"}}
            if (scanJson != null && scanJson.has("data") && scanJson.getAsJsonObject("data").has("id")) {
                return scanJson.getAsJsonObject("data").get("id").getAsString();
            } else {
                log.warn("VirusTotal scan submission response missing 'id' for URL: {}. Response: {}", urlString, responseBody);
                return null;
            }
        }
    }

    private boolean pollForScanResults(String urlString, String scanId) throws IOException, InterruptedException {
        Request analysisRequest = new Request.Builder()
                .url("https://www.virustotal.com/api/v3/analyses/" + scanId)
                .get()
                .addHeader("x-apikey", virusTotalApiKey)
                .addHeader("User-Agent", "Website-Safety-Checker/1.0")
                .build();

        for (int attempt = 0; attempt < maxVirusTotalAttempts; attempt++) {
            if (attempt > 0) {
                log.debug("Polling VirusTotal results for {} (Attempt {}/{})...", urlString, attempt + 1, maxVirusTotalAttempts);
                Thread.sleep(pollDelayMillis);
            }

            try (Response analysisResponse = client.newCall(analysisRequest).execute()) {
                String responseBody = Objects.requireNonNull(analysisResponse.body()).string();

                if (!analysisResponse.isSuccessful()) {
                    log.warn("VirusTotal analysis request failed for URL: {}, status: {}, body: {}",
                            urlString, analysisResponse.code(), responseBody);
                    // On error, we might retry or return false immediately depending on the error code.
                    // For now, continue loop on transient errors, but log and return false on persistent ones.
                    if (analysisResponse.code() == 404 || analysisResponse.code() == 401 || analysisResponse.code() == 403) { // Not found, Unauthorized, Forbidden
                        log.error("VirusTotal API error: {}. Aborting polling for {}", analysisResponse.code(), urlString);
                        return false;
                    }
                    continue; // Retry on other non-successful codes
                }


                JsonObject analysisJson = gson.fromJson(responseBody, JsonObject.class);
                if (analysisJson == null || !analysisJson.has("data") || !analysisJson.getAsJsonObject("data").has("attributes")) {
                    log.warn("VirusTotal analysis response malformed for URL: {}. Response: {}", urlString, responseBody);
                    return false;
                }

                String status = analysisJson.getAsJsonObject("data")
                        .getAsJsonObject("attributes")
                        .get("status").getAsString();

                if ("completed".equals(status)) {
                    return evaluateScanResults(urlString, analysisJson);
                } else if (!"queued".equals(status) && !"running".equals(status)) { // Check for other unexpected statuses
                    log.warn("VirusTotal analysis returned unexpected status: {} for URL: {}", status, urlString);
                    return false;
                }
                // If status is "queued" or "running", continue polling
            }
        }

        log.warn("VirusTotal analysis timed out after {} attempts for URL: {}", maxVirusTotalAttempts, urlString);
        return false;
    }

    private boolean evaluateScanResults(String urlString, JsonObject analysisJson) {
        JsonObject stats = analysisJson.getAsJsonObject("data")
                .getAsJsonObject("attributes")
                .getAsJsonObject("last_analysis_stats"); // Correct field name for v3

        int malicious = stats.has("malicious") ? stats.get("malicious").getAsInt() : 0;
        int suspicious = stats.has("suspicious") ? stats.get("suspicious").getAsInt() : 0;
        int harmless = stats.has("harmless") ? stats.get("harmless").getAsInt() : 0;
        int undetected = stats.has("undetected") ? stats.get("undetected").getAsInt() : 0;

        // A URL is considered unsafe if it has any malicious or suspicious detections
        boolean isSafe = malicious == 0 && suspicious == 0;

        log.info("VirusTotal scan results for URL: {} - malicious: {}, suspicious: {}, harmless: {}, undetected: {}, safe: {}",
                urlString, malicious, suspicious, harmless, undetected, isSafe);

        return isSafe;
    }
}